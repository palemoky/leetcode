# Go 语言核心技巧

本篇整理了 Go 语言开发中关于变量声明、类型转换及数学运算的核心技巧，旨在帮助开发者写出更高效、更安全的 Go 代码。

## 变量声明对比

### 切片与映射 (Slice & Map)

切片（Slice）是 Go 中最常用的数据结构之一，不同的声明方式在底层实现和性能上有显著差异：

| 声明方式            | 底层数组        | 优点                         | 使用场景           | 备注                                                                 |
| ------------------- | --------------- | ---------------------------- | ------------------ | -------------------------------------------------------------------- |
| `var s []T`         | `nil`           | 不分配内存，仅占用结构体空间 | 全局变量、函数签名 | 1. `nil` 切片可以直接 `append`<br />2. 具名返回值 `[]T` 等同于此方式 |
| `s := []T{}`        | 空数组          | 语义明确，序列化后为 `[]`    | 局部变量初始化     | 1. 最常用方式之一<br />2. 扩容时会有性能开销                         |
| `s := make([]T, N)` | 预分配 N 个零值 | **性能最优**，避免频繁扩容   | 已知容量大小的场景 | 如果确定在原值上修改，可直接声明长度；否则推荐使用 `make([]T, 0, N)` |

!!! tip "推荐实践"
在处理大数据量的切片时，务必使用 `make([]T, 0, capacity)` 预分配容量，以大幅提升性能。

### 通道 (Channel)

| 声明方式                | 特性           | 使用场景         | 备注                            |
| ----------------------- | -------------- | ---------------- | ------------------------------- |
| `var ch chan T`         | `nil` channel  | 永远阻塞         | 常用于 `select` 中禁用某个 case |
| `ch := make(chan T)`    | 无缓冲 channel | 同步通信         | 发送方会阻塞直到接收方就绪      |
| `ch := make(chan T, N)` | 有缓冲 channel | 异步通信（解耦） | 缓冲区未满时发送不阻塞          |

---

## 类型转换与性能优化

### `[]byte` 使用指南

在 Go 中，`string` 底层是 `[]byte`。需要注意的是，`string` 是不可变的，而 `[]byte` 是可变的。

#### 常用操作对比

| 操作方式            | 性能 | 内存分配   | 使用场景         | 备注                             |
| ------------------- | ---- | ---------- | ---------------- | -------------------------------- |
| `[]byte(str)`       | 较慢 | 分配新内存 | 基础转换         | 会复制数据，安全但有开销         |
| `bytes.NewBuffer()` | 中等 | 按需分配   | 频繁读写         | 适合动态构建字节流               |
| `unsafe.Slice()`    | 最快 | 无分配     | 性能极度敏感场景 | **危险**，需确保底层数组生命周期 |

#### `[]byte` 与 `string` 互转

| 转换方式          | 开销          | 安全性     | 适用场景               |
| ----------------- | ------------- | ---------- | ---------------------- |
| `string(b)`       | $O(n)$ 复制   | 安全       | 绝大多数场景           |
| `unsafe.String()` | $O(1)$ 零复制 | **不安全** | 追求极限性能的只读场景 |

!!! warning "常见陷阱：频繁转换"

    ```go
    // ❌ 错误做法：在循环中频繁转换，导致大量无意义的内存分配
    for _, str := range strs {
        data := []byte(str)
        process(data)
    }

    // ✅ 正确做法：复用 Buffer，提升性能
    var buf []byte
    for _, str := range strs {
        buf = buf[:0] // 重置长度，保留容量
        buf = append(buf, str...)
        process(buf)
    }
    ```

#### 内存优化技巧

- **预分配容量**：`make([]byte, 0, 1024)` 减少扩容。
- **对象池复用**：在高并发场景下，使用 `sync.Pool` 复用 `[]byte` 或 `bytes.Buffer`。

### 数字与字符串互转 (`strconv`)

在追求性能的场景下，应优先使用 `strconv` 包而非 `fmt` 包。

#### 标准转换方式

| 函数                                 | 功能                      | 性能 | 推荐度     |
| ------------------------------------ | ------------------------- | ---- | ---------- |
| `strconv.Itoa(i)`                    | `int` -> `string`         | 最快 | ⭐⭐⭐⭐⭐ |
| `strconv.Atoi(s)`                    | `string` -> `int`         | 快   | ⭐⭐⭐⭐⭐ |
| `strconv.FormatInt(i, base)`         | `int64` -> `string`(进制) | 快   | ⭐⭐⭐⭐   |
| `strconv.ParseInt(s, base, bitSize)` | `string` -> `int64`       | 快   | ⭐⭐⭐⭐   |
| `fmt.Sprintf("%d", i)`               | 任意转换                  | 最慢 | ⭐         |

!!! success "最佳实践：错误处理"

    ```go
    // ✅ 始终检查 strconv 的错误返回
    num, err := strconv.Atoi(str)
    if err != nil {
        return fmt.Errorf("解析数字失败: %w", err)
    }
    ```

!!! tip "批量转换技巧"

    如果在循环中需要将大量数字转为 `[]byte`，使用 `strconv.AppendInt` 可以直接向缓冲区追加，避免产生中间字符串。

---

## 数学运算小技巧

### 向上取整 (Ceil) 技巧

在处理分页、分片或批处理时，经常需要计算 $a/b$ 的向上取整结果，但直接使用 `math.Ceil` 需要转换浮点数，性能较差。

对于正整数 $a > 0, b > 0$，可使用以下纯整数公式：
$$\text{ceil}(a / b) = \frac{a + b - 1}{b}$$

**原理分析**：
给 $a$ 增加 $b-1$ 的余量。如果 $a$ 能被 $b$ 整除，余量不会导致进位；如果不能整除，余量会确保结果进 1。

**代码示例**：

```go
// 计算需要的块数 (每一块大小为 k)
chunks := (totalSize + k - 1) / k
```

!!! note "注意事项"

    1. 仅适用于 $a > 0$ 且 $b > 0$ 的场景。
    2. 当 $a$ 接近 `MaxInt` 时，需要注意 `a + b - 1` 可能导致的 **整数溢出**，考虑使用 `math.MinInt64` 并检查 `a > math.MaxInt - (b - 1)`。
