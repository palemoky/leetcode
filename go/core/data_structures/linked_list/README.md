

虚头节点：用于统一对头结点和非头结点的处理逻辑，消除对头结点的特殊判断。
当一个链表操作涉及到修改（插入/删除），并且需要为“操作发生在头部”编写特殊逻辑时，它就是使用虚拟头节点的最佳时机
```go
dummy := &ListNode{Next: head}
current := dummy
```

在操作链表时，读写操作分别对应不同的遍历条件
 **特性**                    | **`for current != nil`** | **`for current.Next != nil`**                      
----------------------------|---------------------------|--------------------------------------------------
 **循环体访问范围**           | 访问所有节点                 | 访问除最后一个节点外的所有节点                                  
 **循环结束时 current 的状态** | nil                       | 指向最后一个节点                                         
 **主要用途**                 | 读取/处理每个节点           | 修改/操作节点间的链接                                      
 **安全性**                  | 只需检查 `head == nil`      | 必须检查 `head == nil` 和 `head.Next == nil` (即空链表和单节点链表) 


对于双向链表
1. 空链表 (`ll.Head == nil` 或 `ll.Len == 0`)
2. 单节点链表 (`ll.Head == ll.Tail`)
3. 遍历时可采用二分法来决定从头部还是尾部开始
4. 对头节点的操作 (需要更新 `ll.Head`)
5. 对尾节点的操作 (需要更新 `ll.Tail`)
6. 指针更新的顺序，确保在覆盖一个指针前，所有依赖它的操作都已完成


注意链表插入时，有len+1个位置可以插入，假设插入位置i，则表示插入节点i-1和i之间，如i为1时，表示插入索引0和1之间，即一、二节点之间。


链表操作的注意事项：
1. 空链表
2. 头尾节点的处理
3. 遍历条件
4. 指针操作顺序
5. dummy节点只是辅助工具，不应成为链表的一部分，在写操作完成后，链表的头结点应该是dummy.Next

神器：虚拟头结点

链表测试用例的边界条件：
- 空链表
- 单节点链表
- 头尾操作
- 无效输入

